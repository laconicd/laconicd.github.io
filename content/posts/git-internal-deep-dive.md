+++
title = "Git 내부 동작 원리 파헤치기: 스냅샷부터 팩파일까지"
date = 2025-12-24
description = "Git이 왜 단순한 파일 복사가 아닌지, 내부적으로 데이터를 어떻게 관리하는지 심층 분석합니다."

[taxonomies]
tags = ["git", "devlog", "cs"]
categories = ["development"]
+++

# Git 내부 동작 원리 파헤치기

Git을 사용하면서 흔히 마주치는 용어들과 그 뒤에 숨겨진 효율적인 데이터 관리
구조를 정리합니다.

---

## 1. 머지의 두 얼굴: 이름에 담긴 직관적인 의미

### ⏩ Fast-forward (빨리 감기)

- **상황:** 갈라진 브랜치가 없이 직선상에 있을 때 머지하는 경우.
- **원리:** 새로운 커밋을 만들 필요 없이, 현재 브랜치의 포인터를 앞서 나간
  브랜치로 슬쩍 옮기기만 합니다. 마치 비디오를 **빨리 감기** 하는 것과 같아
  붙여진 이름입니다.

### 🤝 3-way Merge (3자 대면 머지)

- **상황:** 두 브랜치가 서로 다른 길로 갈라졌을 때 합쳐야 하는 경우.
- **원리:** 세 가지 지점을 비교합니다.
  1. **내 브랜치 끝 (Mine)**
  2. **상상대 브랜치 끝 (Theirs)**
  3. **공통 조상 (Base)**
- **논리:** "누가 범인(수정자)인가?"를 따집니다. 조상과 비교했을 때 한쪽만
  수정했다면 그 수정을 반영하고, 양쪽 모두 같은 곳을 다르게 수정했다면
  **충돌(Conflict)**을 발생시켜 사용자에게 합의를 요청합니다.

---

## 2. 커밋은 무엇을 저장하는가? (Snapshot vs Delta)

많은 도구가 파일의 '차이점(Delta)'을 저장하지만, **Git은 '스냅샷(Snapshot)'
방식을 선택했습니다.**

- **스냅샷 방식:** 매 커밋마다 프로젝트 전체의 상태를 사진 찍듯이 저장합니다.
- **효율성:**
  - **변경된 파일:** 통째로 새로 저장 (zlib 압축).
  - **변경되지 않은 파일:** 새로 저장하지 않고 기존 파일에 대한
    **포인터(참조)**만 유지.
- **장점:** 특정 시점으로 돌아가는 속도가 매우 빠르고 데이터의 무결성이
  보장됩니다.

---

## 3. `.git/objects`와 데이터 객체의 삼총사

Git은 모든 데이터를 해시값(SHA-1)으로 관리하며, `.git/objects` 폴더에 세 가지
타입의 객체로 저장합니다.

1. **Blob (Binary Large Object):** 파일의 **내용** 그 자체입니다. 파일 이름은
   보지 않고 오직 내용만으로 해시를 생성하여 중복을 제거합니다.
2. **Tree:** 파일 시스템의 **디렉토리 구조**입니다. 어떤 파일명(Blob)이 어떤
   권한을 가지고 있는지 목록을 관리합니다.
3. **Commit:** 특정 시점의 **Tree**를 가리키며, 작성자, 날짜, 로그 메시지,
   그리고 이전 커밋(Parent)에 대한 정보를 담고 있습니다.

> **💡 핵심:** "내용이 같으면 재활용한다!"는 원리 덕분에 용량을 획기적으로
> 줄입니다.

---

## 4. 용량 관리의 마법: zlib과 Packfiles

### zlib 압축

모든 객체는 기본적으로 zlib으로 압축되어 저장됩니다. 하지만 수천 개의 객체가
생기면 파일 시스템에 부담이 됩니다.

### Packfiles (팩파일)

Git은 특정 기준(보통 객체 약 6,700개)이 넘어가거나 `git gc` 명령어가 실행될 때
**대청소**를 시작합니다.

- **Loose Objects:** 하나씩 흩어져 있던 객체들을 하나로 묶습니다.
- **델타 압축:** 팩파일 안에서는 드디어 '차이점(Delta)' 기반 압축을 수행합니다.
  비슷한 파일들끼리 묶어 중복된 데이터를 날려버려 용량을 극적으로(최대 1/10
  이하로) 줄입니다.

---

## 요약하며

Git은 **"빠른 저장(스냅샷)"**을 위해 평소에는 흩어진 객체로 관리하다가, **"용량
최적화(팩파일)"**가 필요할 때 델타 방식을 섞어 쓰는 아주 영리한 이중 전략을
사용합니다. 이 구조 덕분에 대규모 프로젝트에서도 강력한 성능을 발휘할 수 있는
것입니다.
