window.searchIndex = [{"url":"https://laconicd.github.io/posts/","title":"Posts","description":"","body":"","path":"/posts/"},{"url":"https://laconicd.github.io/posts/modern-css-master-guideline/","title":"현대 CSS 마스터 가이드라인 (v2.5 Final)","description":"현대 CSS의 핵심 원칙인 유지보수성, 독립성, 접근성을 극대화하기 위한 실전 패턴을 집대성한 문서입니다.","body":"🎨 현대 CSS 마스터 가이드라인 (v2.6 Personal)🔗\n유지보수성, 독립성, 접근성. 이 세 가지를 놓치면 결국 나중에 내가 고생한다. 현대 CSS의 핵심 패턴들을 내 것으로 만들고, 실전에서 바로 꺼내 쓸 수 있게 정리해두자.\n1. 🧱 레이아웃 결정 매트릭스 (The Layout Engine)🔗\n**\"2차원은 Grid, 1차원은 Flexbox\"**라는 대원칙 위에, 현대 CSS는 컨테이너의 맥락을 더했다.\nTechnologySituation (WHEN)Power (KEY)\nGrid복잡한 대시보드, 매거진 레이아웃grid-template-areas를 통한 시맨틱 레이아웃 정의\nFlexbox네비게이션, 버튼 그룹, 카드 내부 정렬gap과 flex-basis를 이용한 유연한 분배\nSubgrid부모 그리드와 줄을 맞춰야 하는 중첩 요소grid-template-columns: subgrid;로 부모 간격 상속\n@container배치되는 위치에 따라 모습이 바뀌어야 할 때container-type: inline-size;를 통한 컴포넌트 독립성\n🧩 Subgrid: 중첩 요소의 정렬 종결자🔗\n카드의 제목이나 본문 길이가 달라도, 여러 카드 사이의 줄을 완벽하게 맞출 수 있다.\n📦 @container 스타일 쿼리 (Next Level)🔗\n크기뿐만 아니라 부모의 특정 스타일 상태에 따라 자식을 변화시킬 수 있다.\n2. 📍 정밀 배치와 가변 크기 (Precision &amp; Sizing)🔗\n닻을 내리다: Anchor Positioning🔗\n더 이상 툴팁을 띄우기 위해 getBoundingClientRect() 같은 무거운 JS를 돌리지 말자.\n📏 고정 크기 대신 내재적 크기 (Intrinsic Sizing)🔗\nwidth: 300px 같은 고정값은 위험하다. 콘텐츠의 양에 반응하는 속성을 쓰자.\nmin-content: 최소한의 너비 (단어가 깨지지 않는 선)\nmax-content: 줄바꿈 없는 최대 너비\nfit-content(500px): 콘텐츠에 맞추되, 최대 500px을 넘지 않음\nViewports의 신세계\n모바일 상단바/하단바가 변할 때 레이아웃이 출렁이는 게 싫다면 svh(Small), lvh(Large) 대신 상황에 따라 유동적인 dvh(Dynamic)를 기본값으로 사용하라.\n3. 🎨 색상 시스템 (Color Science)🔗\nOKLCH: 인간 중심의 컬러 모델🔗\nRGB나 HEX는 컴퓨터를 위한 값이다. OKLCH는 사람이 느끼는 '밝기(L)', '채도(C)', '색상(H)'을 기준으로 한다.\nL (Lightness): 0%~100%. 동일한 L값이면 파란색이든 노란색이든 눈에 느껴지는 밝기가 같다.\nC (Chroma): 색의 선명도. 0(무채색)부터 이론상 제한이 없으나 보통 0.4 미만을 쓴다.\n🌗 다크모드와 콘트라스트 (APCA)🔗\n단순히 흰색을 검은색으로 바꾸는 게 아니다.\nLightness Shifting: 배경은 어둡게(L 10%~20%), 텍스트는 밝게(L 90%+) 설정하되 순수한 검정(#000)보다는 짙은 무채색을 선호하라.\nChroma Reduction: 다크모드에서 채도가 너무 높으면 눈이 피로하다. C값을 미세하게 낮춰라.\n4. 🔄 모션 시스템 (Motion Design)🔗\n📽️ View Transitions API🔗\n페이지 이동이나 요소 추가/삭제 시 흐름을 끊지 않는 부드러운 전환을 구현한다.\n📜 스크롤 기반 정밀 제어 (Scroll-Timeline)🔗\nJS 없이 스크롤 위치에 따른 애니메이션의 '진행률'을 정의한다.\n5. 🏗️ 아키텍처와 지능형 선택자 (Architecture)🔗\n🪜 @layer를 활용한 명시도 전쟁 종결🔗\n🕸️ :has() - 부모 선택자의 혁명🔗\n자식의 상태나 존재 여부에 따라 부모의 레이아웃을 바꾼다.\n🎯 @scope - 스타일 오염 방지🔗\n특정 범위 내에서만 스타일이 적용되도록 제한한다.\n6. 🖋️ 타이포그래피 마스터링 (Advanced Typography)🔗\n글자는 단순히 정보를 전달하는 도구가 아니라, 디자인의 핵심이다. 가독성과 심미성을 동시에 잡는 현대적 기법들을 적용하자.\n📏 유연한 크기 조절 (Fluid Typography)🔗\n미디어 쿼리 없이 화면 크기에 따라 폰트 크기가 부드럽게 변하게 만든다.\n🧩 가변 폰트 (Variable Fonts) 활용🔗\n하나의 폰트 파일로 굵기, 너비, 기울기 등을 미세하게 조정한다. font-weight 대신 font-variation-settings를 쓰면 더 세밀한 표현이 가능하다.\n⚖️ 텍스트 균형과 가독성🔗\ntext-wrap: balance: 제목이나 짧은 문구의 줄바꿈을 균등하게 맞춘다. (제목에 필수)\ntext-wrap: pretty: 문단 마지막 줄에 단어 하나만 남는 현상을 방지하여 시각적 불편함을 해소한다.\nmax-inline-size: 65ch: 한 줄의 길이를 약 65자 내외로 제한한다. 인간이 가장 편안하게 읽을 수 있는 너비다.\n🔢 숫자와 장식 스타일링🔗\n데이터나 가격을 표시할 때는 숫자의 높이를 맞추는 것이 중요하다.\nfont-variant-numeric: tabular-nums: 숫자의 너비를 동일하게 맞추어 표나 리스트에서 정렬이 흐트러지지 않게 한다.\ninitial-letter: 문단의 첫 글자를 강조한다.\n폰트 렌더링 최적화\ntext-rendering: optimizeLegibility;를 사용하면 커닝(글자 간격)과 리가처(합자)가 더 정교하게 표현된다. 단, 너무 긴 본문에 쓰면 성능에 영향을 줄 수 있으니 제목 위주로 사용하자.\n7. 🛠️ 코드 작성 철칙 (The CSS Decalogue)🔗\n코드를 짤 때 나만의 엄격한 규칙을 두어야 협업 시 당당하고, 6개월 뒤의 내가 봐도 이해할 수 있다.\n📏 속성 선언 순서: \"바깥에서 안으로 (Outside-In)\"🔗\n브라우저가 요소를 렌더링하는 논리적 순서를 따른다. 이 순서를 지키면 속성 간의 충돌을 직관적으로 파악할 수 있다.\nLayout (흐름과 위치): display, position, grid, flex, float, clear, top/right/bottom/left, z-index\nBox Model (크기와 간격): width, height, margin, padding, border, box-sizing\nTypography (글자 스타일): font, line-height, text-align, color, letter-spacing\nVisual (시각적 장식): background, border-radius, box-shadow, opacity, cursor\nInteraction (동적 효과): transition, animation, transform, will-change\n🏗️ 논리적 속성 사용 (Logical Properties)🔗\n방향 지향(left, right) 대신 흐름 지향(inline, block) 속성을 사용하여 다국어 및 쓰기 방향 대응력을 높인다.\nmargin-left → margin-inline-start\nwidth → inline-size\npadding-top → padding-block-start\n🚫 매직 넘버 금지 (No Magic Numbers)🔗\ntop: 37px; 같은 근거 없는 숫자는 죄악이다. 반드시 변수(var(--spacing-md))나 계산식(calc())을 사용하라.\n최소한의 단위는 4px 또는 8px 배수로 통일한다.\n8. 🔄 실전 개발 루틴 (The 7-Step Routine)🔗\n새로운 UI를 구현할 때 뇌를 비우고 이 순서대로만 움직인다.\n박스 분해 (Anatomy Analysis): 디자인을 보고 'Grid'로 짤 큰 박스와 'Flex'로 짤 작은 박스를 눈으로 먼저 나눈다.\n변수 선언 (Contracting): 해당 컴포넌트에서만 쓸 고유 변수를 :host나 클래스 최상단에 선언한다. (--card-bg, --card-gap 등)\n뼈대 구축 (Layout First): 배경색이나 폰트를 무시하고 display와 gap만 사용하여 전체적인 배치만 잡는다.\n간격 조절 (Sizing): padding과 margin을 넣는다. 이때 em을 써서 폰트 크기 변경에 유연하게 대응할지 결정한다.\n디테일링 (Styling): 폰트, 색상, 그림자 등 시각적 요소를 입힌다.\n반응형 대응 (Fluidity): clamp()나 @container를 이용해 화면 크기 변화에 대응시킨다.\n모션 &amp; 접근성 (Polish): transition을 추가하고, 키보드 포커스(:focus-visible)와 동작 줄이기(prefers-reduced-motion)를 체크한다.\n9. ✅ 최종 체크리스트 (The Quality Gate)🔗\n배포 전, 스스로에게 다음 질문을 던져라.\nTab 키로 이동 가능한가? (Focus Trap 및 시각적 포커스 확인)\n글자 크기를 200% 키워도 레이아웃이 깨지지 않는가?\n이미지가 로드되지 않아도 콘텐츠를 이해할 수 있는가?\n다크모드나 고대비 모드에서 가독성이 확보되는가?\n불필요한 !important가 들어가 있지는 않은가?\n💡 마지막 다짐\n\"Grid로 뼈대를 잡고 OKLCH로 색을 입히자. 모션은 황금 비율과 엇박자 리듬을 섞어 생동감을 주되, 성능과 접근성을 지키는 선을 넘지 말자. 코드 한 줄을 적을 때마다 '왜(Why)'를 생각하는 것이 CSS 마스터로 가는 유일한 길이다.\"","path":"/posts/modern-css-master-guideline/"},{"url":"https://laconicd.github.io/","title":"Blog","description":"","body":"","path":"/"},{"url":"https://laconicd.github.io/posts/modern-css-master-guideline/","title":"현대 CSS 마스터 가이드라인 (v2.5 Final)","description":"현대 CSS의 핵심 원칙인 유지보수성, 독립성, 접근성을 극대화하기 위한 실전 패턴을 집대성한 문서입니다.","body":"🎨 현대 CSS 마스터 가이드라인 (v2.6 Personal)🔗\n유지보수성, 독립성, 접근성. 이 세 가지를 놓치면 결국 나중에 내가 고생한다. 현대 CSS의 핵심 패턴들을 내 것으로 만들고, 실전에서 바로 꺼내 쓸 수 있게 정리해두자.\n1. 🧱 레이아웃 결정 매트릭스 (The Layout Engine)🔗\n**\"2차원은 Grid, 1차원은 Flexbox\"**라는 대원칙 위에, 현대 CSS는 컨테이너의 맥락을 더했다.\nTechnologySituation (WHEN)Power (KEY)\nGrid복잡한 대시보드, 매거진 레이아웃grid-template-areas를 통한 시맨틱 레이아웃 정의\nFlexbox네비게이션, 버튼 그룹, 카드 내부 정렬gap과 flex-basis를 이용한 유연한 분배\nSubgrid부모 그리드와 줄을 맞춰야 하는 중첩 요소grid-template-columns: subgrid;로 부모 간격 상속\n@container배치되는 위치에 따라 모습이 바뀌어야 할 때container-type: inline-size;를 통한 컴포넌트 독립성\n🧩 Subgrid: 중첩 요소의 정렬 종결자🔗\n카드의 제목이나 본문 길이가 달라도, 여러 카드 사이의 줄을 완벽하게 맞출 수 있다.\n📦 @container 스타일 쿼리 (Next Level)🔗\n크기뿐만 아니라 부모의 특정 스타일 상태에 따라 자식을 변화시킬 수 있다.\n2. 📍 정밀 배치와 가변 크기 (Precision &amp; Sizing)🔗\n닻을 내리다: Anchor Positioning🔗\n더 이상 툴팁을 띄우기 위해 getBoundingClientRect() 같은 무거운 JS를 돌리지 말자.\n📏 고정 크기 대신 내재적 크기 (Intrinsic Sizing)🔗\nwidth: 300px 같은 고정값은 위험하다. 콘텐츠의 양에 반응하는 속성을 쓰자.\nmin-content: 최소한의 너비 (단어가 깨지지 않는 선)\nmax-content: 줄바꿈 없는 최대 너비\nfit-content(500px): 콘텐츠에 맞추되, 최대 500px을 넘지 않음\nViewports의 신세계\n모바일 상단바/하단바가 변할 때 레이아웃이 출렁이는 게 싫다면 svh(Small), lvh(Large) 대신 상황에 따라 유동적인 dvh(Dynamic)를 기본값으로 사용하라.\n3. 🎨 색상 시스템 (Color Science)🔗\nOKLCH: 인간 중심의 컬러 모델🔗\nRGB나 HEX는 컴퓨터를 위한 값이다. OKLCH는 사람이 느끼는 '밝기(L)', '채도(C)', '색상(H)'을 기준으로 한다.\nL (Lightness): 0%~100%. 동일한 L값이면 파란색이든 노란색이든 눈에 느껴지는 밝기가 같다.\nC (Chroma): 색의 선명도. 0(무채색)부터 이론상 제한이 없으나 보통 0.4 미만을 쓴다.\n🌗 다크모드와 콘트라스트 (APCA)🔗\n단순히 흰색을 검은색으로 바꾸는 게 아니다.\nLightness Shifting: 배경은 어둡게(L 10%~20%), 텍스트는 밝게(L 90%+) 설정하되 순수한 검정(#000)보다는 짙은 무채색을 선호하라.\nChroma Reduction: 다크모드에서 채도가 너무 높으면 눈이 피로하다. C값을 미세하게 낮춰라.\n4. 🔄 모션 시스템 (Motion Design)🔗\n📽️ View Transitions API🔗\n페이지 이동이나 요소 추가/삭제 시 흐름을 끊지 않는 부드러운 전환을 구현한다.\n📜 스크롤 기반 정밀 제어 (Scroll-Timeline)🔗\nJS 없이 스크롤 위치에 따른 애니메이션의 '진행률'을 정의한다.\n5. 🏗️ 아키텍처와 지능형 선택자 (Architecture)🔗\n🪜 @layer를 활용한 명시도 전쟁 종결🔗\n🕸️ :has() - 부모 선택자의 혁명🔗\n자식의 상태나 존재 여부에 따라 부모의 레이아웃을 바꾼다.\n🎯 @scope - 스타일 오염 방지🔗\n특정 범위 내에서만 스타일이 적용되도록 제한한다.\n6. 🖋️ 타이포그래피 마스터링 (Advanced Typography)🔗\n글자는 단순히 정보를 전달하는 도구가 아니라, 디자인의 핵심이다. 가독성과 심미성을 동시에 잡는 현대적 기법들을 적용하자.\n📏 유연한 크기 조절 (Fluid Typography)🔗\n미디어 쿼리 없이 화면 크기에 따라 폰트 크기가 부드럽게 변하게 만든다.\n🧩 가변 폰트 (Variable Fonts) 활용🔗\n하나의 폰트 파일로 굵기, 너비, 기울기 등을 미세하게 조정한다. font-weight 대신 font-variation-settings를 쓰면 더 세밀한 표현이 가능하다.\n⚖️ 텍스트 균형과 가독성🔗\ntext-wrap: balance: 제목이나 짧은 문구의 줄바꿈을 균등하게 맞춘다. (제목에 필수)\ntext-wrap: pretty: 문단 마지막 줄에 단어 하나만 남는 현상을 방지하여 시각적 불편함을 해소한다.\nmax-inline-size: 65ch: 한 줄의 길이를 약 65자 내외로 제한한다. 인간이 가장 편안하게 읽을 수 있는 너비다.\n🔢 숫자와 장식 스타일링🔗\n데이터나 가격을 표시할 때는 숫자의 높이를 맞추는 것이 중요하다.\nfont-variant-numeric: tabular-nums: 숫자의 너비를 동일하게 맞추어 표나 리스트에서 정렬이 흐트러지지 않게 한다.\ninitial-letter: 문단의 첫 글자를 강조한다.\n폰트 렌더링 최적화\ntext-rendering: optimizeLegibility;를 사용하면 커닝(글자 간격)과 리가처(합자)가 더 정교하게 표현된다. 단, 너무 긴 본문에 쓰면 성능에 영향을 줄 수 있으니 제목 위주로 사용하자.\n7. 🛠️ 코드 작성 철칙 (The CSS Decalogue)🔗\n코드를 짤 때 나만의 엄격한 규칙을 두어야 협업 시 당당하고, 6개월 뒤의 내가 봐도 이해할 수 있다.\n📏 속성 선언 순서: \"바깥에서 안으로 (Outside-In)\"🔗\n브라우저가 요소를 렌더링하는 논리적 순서를 따른다. 이 순서를 지키면 속성 간의 충돌을 직관적으로 파악할 수 있다.\nLayout (흐름과 위치): display, position, grid, flex, float, clear, top/right/bottom/left, z-index\nBox Model (크기와 간격): width, height, margin, padding, border, box-sizing\nTypography (글자 스타일): font, line-height, text-align, color, letter-spacing\nVisual (시각적 장식): background, border-radius, box-shadow, opacity, cursor\nInteraction (동적 효과): transition, animation, transform, will-change\n🏗️ 논리적 속성 사용 (Logical Properties)🔗\n방향 지향(left, right) 대신 흐름 지향(inline, block) 속성을 사용하여 다국어 및 쓰기 방향 대응력을 높인다.\nmargin-left → margin-inline-start\nwidth → inline-size\npadding-top → padding-block-start\n🚫 매직 넘버 금지 (No Magic Numbers)🔗\ntop: 37px; 같은 근거 없는 숫자는 죄악이다. 반드시 변수(var(--spacing-md))나 계산식(calc())을 사용하라.\n최소한의 단위는 4px 또는 8px 배수로 통일한다.\n8. 🔄 실전 개발 루틴 (The 7-Step Routine)🔗\n새로운 UI를 구현할 때 뇌를 비우고 이 순서대로만 움직인다.\n박스 분해 (Anatomy Analysis): 디자인을 보고 'Grid'로 짤 큰 박스와 'Flex'로 짤 작은 박스를 눈으로 먼저 나눈다.\n변수 선언 (Contracting): 해당 컴포넌트에서만 쓸 고유 변수를 :host나 클래스 최상단에 선언한다. (--card-bg, --card-gap 등)\n뼈대 구축 (Layout First): 배경색이나 폰트를 무시하고 display와 gap만 사용하여 전체적인 배치만 잡는다.\n간격 조절 (Sizing): padding과 margin을 넣는다. 이때 em을 써서 폰트 크기 변경에 유연하게 대응할지 결정한다.\n디테일링 (Styling): 폰트, 색상, 그림자 등 시각적 요소를 입힌다.\n반응형 대응 (Fluidity): clamp()나 @container를 이용해 화면 크기 변화에 대응시킨다.\n모션 &amp; 접근성 (Polish): transition을 추가하고, 키보드 포커스(:focus-visible)와 동작 줄이기(prefers-reduced-motion)를 체크한다.\n9. ✅ 최종 체크리스트 (The Quality Gate)🔗\n배포 전, 스스로에게 다음 질문을 던져라.\nTab 키로 이동 가능한가? (Focus Trap 및 시각적 포커스 확인)\n글자 크기를 200% 키워도 레이아웃이 깨지지 않는가?\n이미지가 로드되지 않아도 콘텐츠를 이해할 수 있는가?\n다크모드나 고대비 모드에서 가독성이 확보되는가?\n불필요한 !important가 들어가 있지는 않은가?\n💡 마지막 다짐\n\"Grid로 뼈대를 잡고 OKLCH로 색을 입히자. 모션은 황금 비율과 엇박자 리듬을 섞어 생동감을 주되, 성능과 접근성을 지키는 선을 넘지 말자. 코드 한 줄을 적을 때마다 '왜(Why)'를 생각하는 것이 CSS 마스터로 가는 유일한 길이다.\"","path":"/posts/modern-css-master-guideline/"},{"url":"https://laconicd.github.io/about/","title":"About Me","description":"","body":"Hello, I'm a Developer 👋🔗\nWelcome to my personal blog. I am a software engineer passionate about building\nelegant solutions to complex problems.\nWhat I Do🔗\nI specialize in modern web technologies and love exploring new frameworks and\ntools. My core interests include:\nFrontend Development: Crafting beautiful and performant user interfaces\nwith React, TypeScript, and Tailwind CSS.\nSystem Architecture: Designing scalable and maintainable systems.\nOpen Source: Contributing to the community and learning from others.\nAbout This Blog🔗\nThis site is built using Zola, a fast static site generator written in Rust.\nI use this space to document my learning journey, share technical tutorials, and\npost about my personal projects.\nGet In Touch🔗\nI'm always open to discussing new projects, creative ideas, or opportunities to\nbe part of your visions. Feel free to reach out to me!\nStay hungry, stay foolish.","path":"/about/"}]