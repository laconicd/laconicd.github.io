<my-counter count="10" color="#28a745">
  <template shadowrootmode="open">
    <style>
      :host {
        display: inline-block;
        font-family: system-ui, sans-serif;
        margin: 10px;
      }

      .container {
        border: 1px solid #ccc;
        padding: 15px;
        border-radius: 8px;
        display: flex;
        align-items: center;
        gap: 10px;
      }

      button {
        cursor: pointer;
        background: var(--btn-color, #007bff);
        /* CSS 변수 활용 */
        color: white;
        border: none;
        padding: 8px 12px;
        border-radius: 4px;
        transition: opacity 0.2s;
      }

      button:hover {
        opacity: 0.8;
      }

      #count {
        font-weight: bold;
        font-size: 1.2rem;
      }
    </style>

    <div class="container">
      <strong>Count:</strong>
      <span id="count" aria-live="polite">0</span> <button id="inc" aria-label="Increase count">+</button>
    </div>
  </template>
</my-counter>

<script>
  customElements.define('my-counter', class extends HTMLElement {
    // 1. 감시할 속성 정의
    static get observedAttributes() {
      return ['count', 'color'];
    }

    constructor() {
      super();
      // 초기 상태값 설정
      this._count = 0;
    }

    // 2. DOM에 연결될 때 (하이드레이션 로직)
    connectedCallback() {
      const shadow = this.shadowRoot;
      if (!shadow) return;

      this.btn = shadow.querySelector('#inc');
      this.display = shadow.querySelector('#count');

      // 초기 속성값 반영
      this._count = parseInt(this.getAttribute('count')) || 0;
      this._updateDisplay();

      // 이벤트 바인딩
      this.btn.addEventListener('click', this._increment);

      console.log('MyCounter: Connected and Hydrated');
    }

    // 3. 속성(count, color)이 변경될 때 호출
    attributeChangedCallback(name, oldValue, newValue) {
      if (oldValue === newValue) return;

      if (name === 'count') {
        this._count = parseInt(newValue) || 0;
        this._updateDisplay();
      }
      if (name === 'color') {
        // 스타일 동적 변경 (CSS 변수 활용)
        this.style.setProperty('--btn-color', newValue);
      }
    }

    // 4. DOM에서 제거될 때 (메모리 정리)
    disconnectedCallback() {
      if (this.btn) {
        this.btn.removeEventListener('click', this._increment);
      }
      console.log('MyCounter: Disconnected and Cleaned up');
    }

    // 로직 분리 (화살표 함수로 this 바인딩 고정)
    _increment = () => {
      this._count++;
      // 속성을 직접 업데이트하여 attributeChangedCallback 유도 (데이터 흐름 동기화)
      this.setAttribute('count', this._count);
    };

    _updateDisplay() {
      if (this.display) {
        this.display.textContent = this._count;
      }
    }
  });
</script>