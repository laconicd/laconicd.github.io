1. Navigation API (웹 표준)
기존의 History API(pushState, popState)는 SPA를 위해 설계되어 MPA에서 쓰기 매우 불편했습니다. 이를 대체하기 위해 나온 Navigation API는 MPA에서 다음을 가능하게 합니다.
* 페이지 이동 가로채기: 이동을 완전히 막지 않으면서도, 페이지가 넘어가는 순간을 정교하게 제어할 수 있습니다.
* 상태 복원: 이전 페이지의 스크롤 위치나 폼 입력 데이터 등을 더 쉽게 관리할 수 있도록 설계되었습니다.

2. Speculation Rules API (웹 표준/트렌드)
MPA의 가장 큰 단점인 "네트워크 레이턴시"와 "WASM/JS 로딩 시간"을 해결하는 혁신적인 기술입니다.
* 사전 렌더링 (Prerendering): 사용자가 링크 위에 마우스를 올리기만 해도 브라우저가 배경에서 다음 페이지를 미리 렌더링해둡니다.
* 결과: 링크를 클릭하는 순간, 이미 렌더링이 끝난 페이지가 즉시 교체되므로 WASM 초기화 비용 체감이 0에 수렴하게 됩니다.

3. BFCache (Back-Forward Cache)
표준은 아니지만 모든 현대 브라우저가 목숨 거는 기술입니다.
* 동작: 사용자가 '뒤로 가기'를 눌렀을 때, 페이지를 새로 고치는 게 아니라 이전 페이지의 JS 실행 상태와 DOM을 메모리 그대로 박제해 두었다가 즉시 복원합니다.
* 효과: MPA에서도 뒤로 가기 시에는 데이터가 보존되고 실행 속도가 SPA보다 빨라집니다.

4. Shared Storage & Cookie / IndexedDB (데이터 보존)
메모리(JS 변수)는 사라지지만, 브라우저가 제공하는 영구 저장소 기술이 고도화되고 있습니다.
* Shared Storage API: 보안을 유지하면서 페이지 간 데이터를 공유하는 새로운 방식입니다.
* IndexedDB: WASM에서 거대한 데이터를 로컬에 저장하고 페이지 이동 후에도 즉시 불러올 수 있어, 사실상 "데이터 보존 안 됨" 문제를 아키텍처적으로 해결할 수 있습니다.

5. Persistent UI (고민 중인 과제)
"음악이 끊기지 않아야 한다"와 같은 기능은 여전히 MPA의 숙제입니다. 이를 위해 Portal이라는 표준이 제안되었다가 사라지기도 했고, 현재는 다음과 같은 대안이 논의됩니다.
* Fenced Frames: 독립적인 프레임을 통해 특정 UI(플레이어 등)를 유지하는 방식.
* Service Worker: 네트워크 요청을 가로채서 페이지가 바뀌어도 배경 로직(다운로드 등)이 끊기지 않게 유지---
